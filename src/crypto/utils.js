import * as peculiarWebcrypto from '@peculiar/webcrypto';
import * as x509 from '@peculiar/x509';
import * as nobleEd25519 from '@noble/ed25519';

/**
 * WebCrypto polyfill from @peculiar/webcrypto
 * This behaves differently with respect to Ed25519 keys
 * See: https://github.com/PeculiarVentures/webcrypto/issues/55
 */
const webcrypto = new peculiarWebcrypto.Crypto();

x509.cryptoProvider.set(webcrypto);

async function sleep(ms) {
  return await new Promise((r) => setTimeout(r, ms));
}

export {
  sleep,
  randomBytes,
  generateKeyPairRSA,
  publicKeyFromPrivateKey,
  importPublicKey,
  importPrivateKey,
  keyPairRSAToPEM,
  generateCertificate,
  certToPEM,
  generateKeyHMAC,
  signHMAC,
  verifyHMAC,
};


/**
 * Signs using the 256-bit HMAC key
 * Web Crypto has to use the `CryptoKey` type.
 * But to be fully generic, we use the `ArrayBuffer` type.
 * In production, prefer to use libsodium as it would be faster.
 */
async function signHMAC(key, data) {
  const cryptoKey = await webcrypto.subtle.importKey(
    'raw',
    key,
    {
      name: 'HMAC',
      hash: 'SHA-256',
    },
    true,
    ['sign', 'verify'],
  );
  return webcrypto.subtle.sign('HMAC', cryptoKey, data);
}

/**
 * Verifies using 256-bit HMAC key
 * Web Crypto prefers using the `CryptoKey` type.
 * But to be fully generic, we use the `ArrayBuffer` type.
 * In production, prefer to use libsodium as it would be faster.
 */
async function verifyHMAC(
  key,
  data,
  sig,
) {
  const cryptoKey = await webcrypto.subtle.importKey(
    'raw',
    key,
    {
      name: 'HMAC',
      hash: 'SHA-256',
    },
    true,
    ['sign', 'verify'],
  );
  return webcrypto.subtle.verify('HMAC', cryptoKey, sig, data);
}

function certToPEM(cert) {
  return cert.toString("pem") + "\n";
}

/**
 * Generate 256-bit HMAC key using webcrypto.
 * Web Crypto prefers using the `CryptoKey` type.
 * But to be fully generic, we use the `ArrayBuffer` type.
 * In production, prefer to use libsodium as it would be faster.
 */
async function generateKeyHMAC() {
  const cryptoKey = await webcrypto.subtle.generateKey(
    {
      name: 'HMAC',
      hash: 'SHA-256',
    },
    true,
    ['sign', 'verify'],
  );
  const key = await webcrypto.subtle.exportKey('raw', cryptoKey);
  return key;
}

async function randomBytes(data) {
  webcrypto.getRandomValues(new Uint8Array(data));
}

/**
 * Generates RSA keypair
 */
async function generateKeyPairRSA() {
  const keyPair = await webcrypto.subtle.generateKey(
    {
      name: "RSASSA-PKCS1-v1_5",
      modulusLength: 2048,
      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
      hash: "SHA-256",
    },
    true,
    ["sign", "verify"]
  );
  return {
    publicKey: await webcrypto.subtle.exportKey("jwk", keyPair.publicKey),
    privateKey: await webcrypto.subtle.exportKey("jwk", keyPair.privateKey),
  };
}


async function publicKeyFromPrivateKey(privateKey) {
  switch (privateKey.kty) {
    case "RSA":
      return {
        kty: privateKey.kty,
        alg: privateKey.alg,
        key_ops: ["verify"],
        ext: privateKey.ext,
        n: privateKey.n,
        e: privateKey.e,
      };
    case "EC":
      return {
        kty: privateKey.kty,
        crv: privateKey.crv,
        key_ops: ["verify"],
        ext: true,
        x: privateKey.x,
        y: privateKey.y,
      };
    case "OKP": {
      // For Ed25519 keys generated by @peculiar/webcrypto,
      // we cannot just take the `privateKey.x` as the public key
      // The property does not exist on the JWK, so we have to
      // calculate it using @noble/ed25519
      const publicKey = await nobleEd25519.getPublicKey(
        new Uint8Array(Buffer.from("base64url"))
      );
      return {
        kty: privateKey.kty,
        crv: privateKey.crv,
        key_ops: ["verify"],
        ext: true,
        x: Buffer.from(publicKey).toString("base64url"),
      };
    }
    default:
      throw new Error(`Unsupported key type ${privateKey.kty}`);
  }
}

/**
 * Imports public key.
 * This uses `@peculiar/webcrypto` API for Ed25519 keys.
 */
async function importPublicKey(publicKey) {
  let algorithm;
  switch (publicKey.kty) {
    case "RSA":
      switch (publicKey.alg) {
        case "RS256":
          algorithm = {
            name: "RSASSA-PKCS1-v1_5",
            hash: "SHA-256",
          };
          break;
        case "RS384":
          algorithm = {
            name: "RSASSA-PKCS1-v1_5",
            hash: "SHA-384",
          };
          break;
        case "RS512":
          algorithm = {
            name: "RSASSA-PKCS1-v1_5",
            hash: "SHA-512",
          };
          break;
        default:
          throw new Error(`Unsupported algorithm ${publicKey.alg}`);
      }
      break;
    case "EC":
      switch (publicKey.crv) {
        case "P-256":
          algorithm = {
            name: "ECDSA",
            namedCurve: "P-256",
          };
          break;
        case "P-384":
          algorithm = {
            name: "ECDSA",
            namedCurve: "P-384",
          };
          break;
        case "P-521":
          algorithm = {
            name: "ECDSA",
            namedCurve: "P-521",
          };
          break;
        default:
          throw new Error(`Unsupported curve ${publicKey.crv}`);
      }
      break;
    case "OKP":
      algorithm = {
        name: "EdDSA",
        namedCurve: "Ed25519",
      };
      break;
    default:
      throw new Error(`Unsupported key type ${publicKey.kty}`);
  }
  return await webcrypto.subtle.importKey("jwk", publicKey, algorithm, true, [
    "verify",
  ]);
}

/**
 * Imports private key.
 * This uses `@peculiar/webcrypto` API for Ed25519 keys.
 */
async function importPrivateKey(privateKey) {
  let algorithm;
  switch (privateKey.kty) {
    case "RSA":
      switch (privateKey.alg) {
        case "RS256":
          algorithm = {
            name: "RSASSA-PKCS1-v1_5",
            hash: "SHA-256",
          };
          break;
        case "RS384":
          algorithm = {
            name: "RSASSA-PKCS1-v1_5",
            hash: "SHA-384",
          };
          break;
        case "RS512":
          algorithm = {
            name: "RSASSA-PKCS1-v1_5",
            hash: "SHA-512",
          };
          break;
        default:
          throw new Error(`Unsupported algorithm ${privateKey.alg}`);
      }
      break;
    case "EC":
      switch (privateKey.crv) {
        case "P-256":
          algorithm = {
            name: "ECDSA",
            namedCurve: "P-256",
          };
          break;
        case "P-384":
          algorithm = {
            name: "ECDSA",
            namedCurve: "P-384",
          };
          break;
        case "P-521":
          algorithm = {
            name: "ECDSA",
            namedCurve: "P-521",
          };
          break;
        default:
          throw new Error(`Unsupported curve ${privateKey.crv}`);
      }
      break;
    case "OKP":
      algorithm = {
        name: "EdDSA",
        namedCurve: "Ed25519",
      };
      break;
    default:
      throw new Error(`Unsupported key type ${privateKey.kty}`);
  }
  return await webcrypto.subtle.importKey("jwk", privateKey, algorithm, true, [
    "sign",
  ]);
}

const extendedKeyUsageFlags = {
  serverAuth: "1.3.6.1.5.5.7.3.1",
  clientAuth: "1.3.6.1.5.5.7.3.2",
  codeSigning: "1.3.6.1.5.5.7.3.3",
  emailProtection: "1.3.6.1.5.5.7.3.4",
  timeStamping: "1.3.6.1.5.5.7.3.8",
  ocspSigning: "1.3.6.1.5.5.7.3.9",
};

/**
 * Generate x509 certificate.
 * Duration is in seconds.
 * X509 certificates currently use `UTCTime` format for `notBefore` and `notAfter`.
 * This means:
 *   - Only second resolution.
 *   - Minimum date for validity is 1970-01-01T00:00:00Z (inclusive).
 *   - Maximum date for valdity is 2049-12-31T23:59:59Z (inclusive).
 */
async function generateCertificate({
  certId,
  subjectKeyPair,
  issuerPrivateKey,
  duration,
  subjectAttrsExtra = [],
  issuerAttrsExtra = [],
  now = new Date(),
}) {
  const subjectPublicCryptoKey = await importPublicKey(
    subjectKeyPair.publicKey,
  );
  const subjectPrivateCryptoKey = await importPrivateKey(
    subjectKeyPair.privateKey,
  );
  const issuerPrivateCryptoKey = await importPrivateKey(issuerPrivateKey);
  if (duration < 0) {
    throw new RangeError('`duration` must be positive');
  }
  // X509 `UTCTime` format only has resolution of seconds
  // this truncates to second resolution
  const notBeforeDate = new Date(now.getTime() - (now.getTime() % 1000));
  const notAfterDate = new Date(now.getTime() - (now.getTime() % 1000));
  // If the duration is 0, then only the `now` is valid
  notAfterDate.setSeconds(notAfterDate.getSeconds() + duration);
  if (notBeforeDate < new Date(0)) {
    throw new RangeError(
      '`notBeforeDate` cannot be before 1970-01-01T00:00:00Z',
    );
  }
  if (notAfterDate > new Date(new Date('2050').getTime() - 1)) {
    throw new RangeError('`notAfterDate` cannot be after 2049-12-31T23:59:59Z');
  }
  const subjectNodeId = await webcrypto.subtle.digest(
    'SHA-256',
    await webcrypto.subtle.exportKey('spki', subjectPublicCryptoKey),
  );
  const issuerPublicKey = await publicKeyFromPrivateKey(issuerPrivateKey);
  const issuerPublicCryptoKey = await importPublicKey(issuerPublicKey);
  const issuerNodeId = await webcrypto.subtle.digest(
    'SHA-256',
    await webcrypto.subtle.exportKey('spki', issuerPublicCryptoKey),
  );
  const serialNumber = certId;
  const subjectNodeIdEncoded = Buffer.from(subjectNodeId).toString('hex');
  const issuerNodeIdEncoded = Buffer.from(issuerNodeId).toString('hex');
  // The entire subject attributes and issuer attributes
  // is constructed via `x509.Name` class
  // By default this supports on a limited set of names:
  // CN, L, ST, O, OU, C, DC, E, G, I, SN, T
  // If custom names are desired, this needs to change to constructing
  // `new x509.Name('FOO=BAR', { FOO: '1.2.3.4' })` manually
  // And each custom attribute requires a registered OID
  // Because the OID is what is encoded into ASN.1
  const subjectAttrs = [
    {
      CN: [subjectNodeIdEncoded],
    },
    // Filter out conflicting CN attributes
    ...subjectAttrsExtra.filter((attr) => !('CN' in attr)),
  ];
  const issuerAttrs = [
    {
      CN: [issuerNodeIdEncoded],
    },
    // Filter out conflicting CN attributes
    ...issuerAttrsExtra.filter((attr) => !('CN' in attr)),
  ];
  const signingAlgorithm = issuerPrivateCryptoKey.algorithm;
  if (signingAlgorithm.name === 'ECDSA') {
    // In ECDSA, the signature should match the curve strength
    switch (signingAlgorithm.namedCurve) {
      case 'P-256':
        signingAlgorithm.hash = 'SHA-256';
        break;
      case 'P-384':
        signingAlgorithm.hash = 'SHA-384';
        break;
      case 'P-521':
        signingAlgorithm.hash = 'SHA-512';
        break;
      default:
        throw new TypeError(
          `Issuer private key has an unsupported curve: ${signingAlgorithm.namedCurve}`,
        );
    }
  }
  const certConfig = {
    serialNumber,
    notBefore: notBeforeDate,
    notAfter: notAfterDate,
    subject: subjectAttrs,
    issuer: issuerAttrs,
    signingAlgorithm,
    publicKey: subjectPublicCryptoKey,
    signingKey: subjectPrivateCryptoKey,
    extensions: [
      new x509.BasicConstraintsExtension(true),
      new x509.KeyUsagesExtension(
        x509.KeyUsageFlags.keyCertSign |
          x509.KeyUsageFlags.cRLSign |
          x509.KeyUsageFlags.digitalSignature |
          x509.KeyUsageFlags.nonRepudiation |
          x509.KeyUsageFlags.keyAgreement |
          x509.KeyUsageFlags.keyEncipherment |
          x509.KeyUsageFlags.dataEncipherment,
      ),
      new x509.ExtendedKeyUsageExtension([
        extendedKeyUsageFlags.serverAuth,
        extendedKeyUsageFlags.clientAuth,
        extendedKeyUsageFlags.codeSigning,
        extendedKeyUsageFlags.emailProtection,
        extendedKeyUsageFlags.timeStamping,
        extendedKeyUsageFlags.ocspSigning,
      ]),
      new x509.SubjectAlternativeNameExtension([
        {
          type: 'dns',
          value: subjectNodeIdEncoded,
        },
        {
          type: 'dns',
          value: 'localhost',
        },
        // Quiche doesn't support IP SANs,
        // instead we hack these in as DNS SANs for testing purposes
        {
          type: 'dns',
          value: '127.0.0.1',
        },
        // Quiche doesn't support IP SANs,
        // instead we hack these in as DNS SANs for testing purposes
        {
          type: 'dns',
          value: '::1',
        },
        {
          type: 'ip',
          value: '127.0.0.1',
        },
        {
          type: 'ip',
          value: '::1',
        },
      ]),
      await x509.SubjectKeyIdentifierExtension.create(subjectPublicCryptoKey),
    ],
  };
  certConfig.signingKey = issuerPrivateCryptoKey;
  return await x509.X509CertificateGenerator.create(certConfig);
}

async function keyPairRSAToPEM(keyPair) {
  const publicKey = await importPublicKey(keyPair.publicKey);
  const privatekey = await importPrivateKey(keyPair.privateKey);
  const publicKeySPKI = await webcrypto.subtle.exportKey("spki", publicKey);
  const publicKeySPKIBuffer = Buffer.from(publicKeySPKI);
  const publicKeyPEMBody =
    publicKeySPKIBuffer
      .toString("base64")
      .replace(/(.{64})/g, "$1\n")
      .trimEnd() + "\n";
  const publicKeyPEM = `-----BEGIN PUBLIC KEY-----\n${publicKeyPEMBody}\n-----END PUBLIC KEY-----\n`;
  const privateKeyPKCS8 = await webcrypto.subtle.exportKey("pkcs8", privatekey);
  const privateKeyPKCS8Buffer = Buffer.from(privateKeyPKCS8);
  const privateKeyPEMBody =
    privateKeyPKCS8Buffer
      .toString("base64")
      .replace(/(.{64})/g, "$1\n")
      .trimEnd() + "\n";
  const privateKeyPEM = `-----BEGIN PRIVATE KEY-----\n${privateKeyPEMBody}-----END PRIVATE KEY-----\n`;
  return {
    publicKey: publicKeyPEM,
    privateKey: privateKeyPEM,
  };
}

